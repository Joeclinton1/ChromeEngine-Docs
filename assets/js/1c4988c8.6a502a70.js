"use strict";(self.webpackChunkchrome_engine_docs=self.webpackChunkchrome_engine_docs||[]).push([[360],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=i.createContext({}),d=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(p.Provider,{value:t},e.children)},h="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),h=d(n),u=r,m=h["".concat(p,".").concat(u)]||h[u]||l[u]||s;return n?i.createElement(m,o(o({ref:t},c),{},{components:n})):i.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var a={};for(var p in t)hasOwnProperty.call(t,p)&&(a[p]=t[p]);a.originalType=e,a[h]="string"==typeof e?e:r,o[1]=a;for(var d=2;d<s;d++)o[d]=n[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6642:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>p});var i=n(7462),r=(n(7294),n(3905));const s={},o="Bounding Spheres Generation",a={unversionedId:"system_docs/Physics/BoundingSpheres",id:"system_docs/Physics/BoundingSpheres",isDocsHomePage:!1,title:"Bounding Spheres Generation",description:"The following custom block definitions are present in the Bounding Spheres Generation code:",source:"@site/docs/system_docs/02-Physics/00-BoundingSpheres.md",sourceDirName:"system_docs/02-Physics",slug:"/system_docs/Physics/BoundingSpheres",permalink:"/docs/system_docs/Physics/BoundingSpheres",editUrl:"https://github.com/your-github-username/your-repo-name/edit/main/docs/docs/system_docs/02-Physics/00-BoundingSpheres.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{},sidebar:"systemSidebar",previous:{title:"Subtrees for dynamic objects",permalink:"/docs/system_docs/BSP/Dynamic Objects"},next:{title:"Rigid Body Physics",permalink:"/docs/system_docs/Physics/Rigid Body Physics"}},p=[{value:"Custom Block Descriptions",id:"custom-block-descriptions",children:[{value:"primitives.generate_bounding_spheres",id:"primitivesgenerate_bounding_spheres",children:[]},{value:"GameObjects.generate_bounding_spheres",id:"gameobjectsgenerate_bounding_spheres",children:[]},{value:"_x, _y, _z, _r = RitterSphere",id:"_x-_y-_z-_r--rittersphere",children:[]},{value:"_x,_y,_z,_r = SphereFromDistantPoints",id:"_x_y_z_r--spherefromdistantpoints",children:[]},{value:"_min, _max = MostSeparatedPointsOnAABB",id:"_min-_max--mostseparatedpointsonaabb",children:[]},{value:"_x,_y,_z,_r = SphereOfSphereAndPt",id:"_x_y_z_r--sphereofsphereandpt",children:[]}]}],d=(c="ScratchBlocks",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var c;const h={toc:p},l="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(l,(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"bounding-spheres-generation"},"Bounding Spheres Generation"),(0,r.kt)("p",null,"The following custom block definitions are present in the Bounding Spheres Generation code:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"primitives.generate_bounding_spheres")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"GameObjects.generate_bounding_spheres")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"_x, _y, _z, _r = RitterSphere")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"_x,_y,_z,_r = SphereFromDistantPoints")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"_min, _max = MostSeparatedPointsOnAABB")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"_x,_y,_z,_r = SphereOfSphereAndPt"))),(0,r.kt)("h2",{id:"custom-block-descriptions"},"Custom Block Descriptions"),(0,r.kt)("h3",{id:"primitivesgenerate_bounding_spheres"},"primitives.generate_bounding_spheres"),(0,r.kt)(d,{mdxType:"ScratchBlocks"},"\ndefine primitives.generate_bounding_spheres \\(\\)\n"),(0,r.kt)("p",null,"This custom block calculates the bounding spheres for each primitive. It starts by initializing ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prim")," to 1 and then repeating the calculations for each primitive. If the primitive is not a container, it adds the primitive to the ",(0,r.kt)("inlineCode",{parentName:"p"},"idxs_tmp")," list and calculates the bounding sphere using the Ritter Sphere algorithm. It adds the bounding sphere coordinates and radius to the ",(0,r.kt)("inlineCode",{parentName:"p"},"bsphere_buff")," list and updates the primitive's ",(0,r.kt)("inlineCode",{parentName:"p"},"*BSPHERE")," attribute. If the primitive has less than three vertices, it adds the primitive's radius to the bounding sphere radius. Finally, it copies all the calculated bounding spheres to the ",(0,r.kt)("inlineCode",{parentName:"p"},"bsphere_world")," list."),(0,r.kt)("h3",{id:"gameobjectsgenerate_bounding_spheres"},"GameObjects.generate_bounding_spheres"),(0,r.kt)(d,{mdxType:"ScratchBlocks"},"\ndefine GameObjects.generate_bounding_spheres \\(\\)\n"),(0,r.kt)("p",null,"This custom block calculates the bounding spheres for each game object, following a similar process as the ",(0,r.kt)("inlineCode",{parentName:"p"},"primitives.generate_bounding_spheres")," block. It adds each vertex of the object to the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tmp")," list and calculates the bounding sphere using the Ritter Sphere algorithm. It adds the bounding sphere coordinates and radius to the ",(0,r.kt)("inlineCode",{parentName:"p"},"bsphere_buff")," list, updates the object's ",(0,r.kt)("inlineCode",{parentName:"p"},"*BSPHERE")," attribute, and copies all the calculated bounding spheres to the ",(0,r.kt)("inlineCode",{parentName:"p"},"bsphere_world")," list."),(0,r.kt)("h3",{id:"_x-_y-_z-_r--rittersphere"},"_x, _y, _z, _r = RitterSphere"),(0,r.kt)(d,{mdxType:"ScratchBlocks"},"\ndefine _x, _y, _z, _r = RitterSphere \\( (*tmp) \\)\n"),(0,r.kt)("p",null,"This custom block calculates the bounding sphere for a set of vertices stored in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tmp")," list using the Ritter Sphere algorithm. It starts by calculating an initial bounding sphere from the two most distant points in the list, and then checks each remaining vertex in the list. If a vertex is outside the current bounding sphere, it calculates a new bounding sphere that includes the vertex and the current bounding sphere."),(0,r.kt)("h3",{id:"_x_y_z_r--spherefromdistantpoints"},"_x,_y,_z,_r = SphereFromDistantPoints"),(0,r.kt)(d,{mdxType:"ScratchBlocks"},"\ndefine _x,_y,_z,_r = SphereFromDistantPoints \\( (*tmp) \\)\n"),(0,r.kt)("p",null,"This custom block calculates a bounding sphere from the two most distant points in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tmp")," list. It first identifies these points using the ",(0,r.kt)("inlineCode",{parentName:"p"},"MostSeparatedPointsOnAABB")," block, and then calculates the center of the bounding sphere as the midpoint between the points, and the radius as the half of the distance between the points."),(0,r.kt)("h3",{id:"_min-_max--mostseparatedpointsonaabb"},"_min, _max = MostSeparatedPointsOnAABB"),(0,r.kt)(d,{mdxType:"ScratchBlocks"},"\ndefine _min, _max = MostSeparatedPointsOnAABB \\( (*tmp) \\)\n"),(0,r.kt)("p",null,"This custom block identifies the two most separated points on an axis-aligned bounding box (AABB) from a list of vertices stored in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tmp")," list. It iterates over the list three vertices at a time (representing the x, y, and z coordinates of each"),(0,r.kt)("p",null," vertex), finding the minimum and maximum x, y, and z values. It calculates the squared distance between the minimum and maximum points for each dimension, and returns the indices of the two most separated points."),(0,r.kt)("h3",{id:"_x_y_z_r--sphereofsphereandpt"},"_x,_y,_z,_r = SphereOfSphereAndPt"),(0,r.kt)(d,{mdxType:"ScratchBlocks"},"\ndefine _x,_y,_z,_r = SphereOfSphereAndPt \\( Sphere (Sx) (Sy) (Sz) (Sr), Pt (Px) (Py) (Pz) \\)\n"),(0,r.kt)("p",null,"This custom block calculates a new bounding sphere that includes a given point and a current bounding sphere. If the given point is outside the current bounding sphere, it calculates a new bounding sphere with a radius half way between the current bounding sphere and the given point, and a center that lies on the line between the center of the current bounding sphere and the given point, closer to the given point."))}u.isMDXComponent=!0}}]);