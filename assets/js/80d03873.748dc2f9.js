"use strict";(self.webpackChunkchrome_engine_docs=self.webpackChunkchrome_engine_docs||[]).push([[233],{3905:(e,t,i)=>{i.d(t,{Zo:()=>d,kt:()=>y});var o=i(7294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,o)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,o,n=function(e,t){if(null==e)return{};var i,o,n={},l=Object.keys(e);for(o=0;o<l.length;o++)i=l[o],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)i=l[o],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var a=o.createContext({}),c=function(e){var t=o.useContext(a),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},d=function(e){var t=c(e.components);return o.createElement(a.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var i=e.components,n=e.mdxType,l=e.originalType,a=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(i),m=n,y=p["".concat(a,".").concat(m)]||p[m]||h[m]||l;return i?o.createElement(y,r(r({ref:t},d),{},{components:i})):o.createElement(y,r({ref:t},d))}));function y(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=i.length,r=new Array(l);r[0]=m;var s={};for(var a in t)hasOwnProperty.call(t,a)&&(s[a]=t[a]);s.originalType=e,s[p]="string"==typeof e?e:n,r[1]=s;for(var c=2;c<l;c++)r[c]=i[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,i)}m.displayName="MDXCreateElement"},6814:(e,t,i)=>{i.r(t),i.d(t,{contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>a});var o=i(7462),n=(i(7294),i(3905));const l={},r="Rigid Body Physics",s={unversionedId:"system_docs/Physics/Rigid Body Physics",id:"system_docs/Physics/Rigid Body Physics",isDocsHomePage:!1,title:"Rigid Body Physics",description:"What is it?",source:"@site/docs/system_docs/02-Physics/01-Rigid Body Physics.md",sourceDirName:"system_docs/02-Physics",slug:"/system_docs/Physics/Rigid Body Physics",permalink:"/ChromeEngine-Docs/docs/system_docs/Physics/Rigid Body Physics",editUrl:"https://github.com/your-github-username/your-repo-name/edit/main/docs/docs/system_docs/02-Physics/01-Rigid Body Physics.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"systemSidebar",previous:{title:"Bounding Spheres Generation",permalink:"/ChromeEngine-Docs/docs/system_docs/Physics/BoundingSpheres"},next:{title:"Collision Tests",permalink:"/ChromeEngine-Docs/docs/system_docs/Physics/Collision Tests"}},a=[{value:"What is it?",id:"what-is-it",children:[]},{value:"<code>Physics</code> pseudo code",id:"physics-pseudo-code",children:[]},{value:"<code>Collision resolution</code> pseudo code",id:"collision-resolution-pseudo-code",children:[]}],c={toc:a},d="wrapper";function p(e){let{components:t,...i}=e;return(0,n.kt)(d,(0,o.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"rigid-body-physics"},"Rigid Body Physics"),(0,n.kt)("h2",{id:"what-is-it"},"What is it?"),(0,n.kt)("p",null,"ChromeEngine contains a powerful 3D rigid body physics engine. It is a simplified 3D version of Randy Gaul's ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/RandyGaul/ImpulseEngine"},"ImpulseEngine"),". Critically this engine operates fully under the assumption that all forces during a collision are the same as an objects impulse value during a collision."),(0,n.kt)("h2",{id:"physics-pseudo-code"},(0,n.kt)("inlineCode",{parentName:"h2"},"Physics")," pseudo code"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Update the players velocity",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"Iterate over the ",(0,n.kt)("inlineCode",{parentName:"li"},"@player_forces")," list and determine the element wise sum of all the forces, then add this to the Players physical velocity."),(0,n.kt)("li",{parentName:"ol"},"Add the force vector as set by the first three items of the ",(0,n.kt)("inlineCode",{parentName:"li"},"@player_forces_controlled")," list to the Players controlled velocity."),(0,n.kt)("li",{parentName:"ol"},"Update the player velocity to be a combination of it's physical and controlled velocity. The physical velocity is multiplied by ",(0,n.kt)("inlineCode",{parentName:"li"},"delta_t")," to account for frame rate."),(0,n.kt)("li",{parentName:"ol"},"Dampen both controlled and physical velocity"))),(0,n.kt)("li",{parentName:"ol"},"Update player position using it's velocity"),(0,n.kt)("li",{parentName:"ol"},"Detect all collisions (discussed in detail in the ",(0,n.kt)("a",{parentName:"li",href:"/docs/system_docs/Physics/Collision%20Tests"},"Collision Tests")," section)"),(0,n.kt)("li",{parentName:"ol"},"Resolve the collision with earliest time of impact."),(0,n.kt)("li",{parentName:"ol"},"Resolve remaining collisions in random order")),(0,n.kt)("h2",{id:"collision-resolution-pseudo-code"},(0,n.kt)("inlineCode",{parentName:"h2"},"Collision resolution")," pseudo code"),(0,n.kt)("p",null,"Collision resolution involves the following steps:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Retrieve the collision information"),(0,n.kt)("li",{parentName:"ol"},"If the collision penetrated deeper than ",(0,n.kt)("inlineCode",{parentName:"li"},"@penetration_thresh"),", move the player backwards along the collision normal so it is no longer penetrating"),(0,n.kt)("li",{parentName:"ol"},"Add the collision forces associated with the collision.",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"If the object is moving then we find the Angular and tangential velocity of the object's moving/spinning bounding sphere at the players location."),(0,n.kt)("li",{parentName:"ol"},"We calculate the magnitude of the collision force as the dot product of the player's velocity minus the objects velocity and the collision normal."),(0,n.kt)("li",{parentName:"ol"},"We add a force with this magnitude in the direction of the collision normal multiplied 1 + the ",(0,n.kt)("inlineCode",{parentName:"li"},"_restitution")," value of the materia to the ",(0,n.kt)("inlineCode",{parentName:"li"},"@player_forces")," list",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"since we want it to apply a force which cancels out all the forwards velocity of the player and then additional force (",(0,n.kt)("inlineCode",{parentName:"li"},"_restitution"),") which bounces it backwards."))),(0,n.kt)("li",{parentName:"ol"},"We calculate the magnitude of the collision force again like before but using the players physical velocity only"),(0,n.kt)("li",{parentName:"ol"},"We calculate the tagential component of the collision force by subtracting the main collision force from the players physical velocity minus the objects velocity. We add this tangential force to the ",(0,n.kt)("inlineCode",{parentName:"li"},"@player_forces")," list.",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"We also prefix it's label with a \"t:\" to make it clear that it's tagential force.")))))))}p.isMDXComponent=!0}}]);