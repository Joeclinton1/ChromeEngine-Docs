"use strict";(self.webpackChunkchrome_engine_docs=self.webpackChunkchrome_engine_docs||[]).push([[679],{3905:(e,t,o)=>{o.d(t,{Zo:()=>m,kt:()=>h});var n=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)o=i[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},m=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var o=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=c(o),u=a,h=p["".concat(s,".").concat(u)]||p[u]||d[u]||i;return o?n.createElement(h,r(r({ref:t},m),{},{components:o})):n.createElement(h,r({ref:t},m))}));function h(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=o.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<i;c++)r[c]=o[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,o)}u.displayName="MDXCreateElement"},6366:(e,t,o)=>{o.r(t),o.d(t,{contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=o(7462),a=(o(7294),o(3905));const i={},r="Moving Objects",l={unversionedId:"tutorials/Platformer Tutorial/Moving Objects",id:"tutorials/Platformer Tutorial/Moving Objects",isDocsHomePage:!1,title:"Moving Objects",description:"Hello, future game designers! We've laid the foundation, now it's time to kick things up a notch and breathe life into our game with moving platforms and hopping enemies! Ready to dive into the dynamic world of ChromeEngine? Let's get to it!",source:"@site/docs/tutorials/01-Platformer Tutorial/04-Moving Objects.md",sourceDirName:"tutorials/01-Platformer Tutorial",slug:"/tutorials/Platformer Tutorial/Moving Objects",permalink:"/docs/tutorials/Platformer Tutorial/Moving Objects",editUrl:"https://github.com/your-github-username/your-repo-name/edit/main/docs/docs/tutorials/01-Platformer Tutorial/04-Moving Objects.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialsSidebar",previous:{title:"The Player",permalink:"/docs/tutorials/Platformer Tutorial/The Player"},next:{title:"Interactive Game Elements",permalink:"/docs/tutorials/Platformer Tutorial/Interactive Game Elements"}},s=[{value:"Mark Dynamic Objects",id:"mark-dynamic-objects",children:[]},{value:"The 3 logic blocks",id:"the-3-logic-blocks",children:[]},{value:"Making our platforms move",id:"making-our-platforms-move",children:[]},{value:"Making our platforms spin",id:"making-our-platforms-spin",children:[]},{value:"Moving our enemy towards the player",id:"moving-our-enemy-towards-the-player",children:[{value:"<code>pointTowardsPosition</code> block",id:"pointtowardsposition-block",children:[]},{value:"<code>move</code> block",id:"move-block",children:[]},{value:"Restricting the enemy&#39;s movement and rotation",id:"restricting-the-enemys-movement-and-rotation",children:[]}]},{value:"Wrapping up and Additional Resources",id:"wrapping-up-and-additional-resources",children:[]}],c=(m="ScratchBlocks",function(e){return console.warn("Component "+m+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)});var m;const p={toc:s},d="wrapper";function u(e){let{components:t,...i}=e;return(0,a.kt)(d,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"moving-objects"},"Moving Objects"),(0,a.kt)("p",null,"Hello, future game designers! We've laid the foundation, now it's time to kick things up a notch and breathe life into our game with moving platforms and hopping enemies! Ready to dive into the dynamic world of ChromeEngine? Let's get to it!"),(0,a.kt)("h3",{id:"mark-dynamic-objects"},"Mark Dynamic Objects"),(0,a.kt)("p",null,'Before we make anything move we need to tell ChromeEngine, that we want our objects to be "dynamic" otherwise it won\'t sort them correctly when rendering. We can do this using the ',(0,a.kt)("inlineCode",{parentName:"p"},"GameObjects.set_dynamic ( )")," block. Add the following to the end of the ",(0,a.kt)("inlineCode",{parentName:"p"},"setup scene objects")," block in ",(0,a.kt)("inlineCode",{parentName:"p"},"Setup"),":"),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n  GameObjects.setDynamic \\( object name [Enemy] parent object []\\) :: custom\n  GameObjects.setDynamic \\( object name [Platform 3] parent object []\\) :: custom\n  GameObjects.setDynamic \\( object name [Platform 5] parent object []\\) :: custom\n"),(0,a.kt)("p",null,"It's super important to remember to always start by marking your moving objects as dynamic or things might not behave as expected!"),(0,a.kt)("h2",{id:"the-3-logic-blocks"},"The 3 logic blocks"),(0,a.kt)("p",null,"In ChromeEngine all game logic should go inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"Logic")," sprite in one ",(0,a.kt)("inlineCode",{parentName:"p"},"Play Logic"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Edit Logic")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Play and Edit Logic"),". Each of these serves a different purpose described below:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"Play Logic")),": this logic will be called only during play mode, aka when the player is playing the game. You won't see this whilst in edit mode."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"Edit Logic")),": this logic will be called only during edit mode, it used for logic which you only want to happen whilst editing the project. You won't need to change this much."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"Play and Edit Logic")),": this is for any logic you want to take place in both play mode and edit mode. Most of your logic should go here, as it lets you experience it both whilst editing and playing.")),(0,a.kt)("p",null,"For the rest of this section of the tutorial, assume that any logic blocks are being placed in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Play and Edit Logic")," block. This looks like:"),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n  define Play and Edit Logic\n"),(0,a.kt)("h2",{id:"making-our-platforms-move"},"Making our platforms move"),(0,a.kt)("p",null,"For ",(0,a.kt)("inlineCode",{parentName:"p"},"Platform 3"),", we're going to make it move. We can do this using the ",(0,a.kt)("inlineCode",{parentName:"p"},"GameObject.setPosition")," block. This block allows us to control where our game objects exist in our 3D game world. The function takes the name of the object we want to manipulate and the x, y, and z coordinates of the new position. "),(0,a.kt)("p",null,"Here's how we can use it to make ",(0,a.kt)("inlineCode",{parentName:"p"},"Platform 3")," move sway back and forth on both the y and z-axis, aka Diagonally! "),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n  GameObject.setPosition \\( object name [Platform 3] position [0.6] ([3.6] + ([1.8] * ([cos v] of ((timer) * [50])))) ([-5.2] + ([-1.4] * ([sin v] of ((timer) * [50])))) \\):: custom\n"),(0,a.kt)("p",null,"This might look a little complicated but all we're doing is moving the platform along an elliptical path with centre at the original position of ",(0,a.kt)("inlineCode",{parentName:"p"},"Platform 3")," using Sine, Cosine and the timer value."),(0,a.kt)("h2",{id:"making-our-platforms-spin"},"Making our platforms spin"),(0,a.kt)("p",null,"For ",(0,a.kt)("inlineCode",{parentName:"p"},"Platform 5"),", we want it to rotate in place around the y-axis (yaw), like a spinning top! We can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"GameObject.setRotation")," block to achieve this effect. This block takes the name of our object and some specific inputs - the yaw, pitch and roll to define the new rotation."),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n  GameObjects.setRotation \\( object name [Platform 5] rotation \\(yaw, pitch, roll\\) (([sin v] of (timer)) * [180])  [] []   \\) :: custom\n"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Pro-tip"),": If you leave any of the values empty for the position or rotation, that value won't be set."),(0,a.kt)("p",null,"If you aren't familiar with yaw, pitch and roll, then just just know that yaw rotates around the y-axis, pitch around the x-axis and roll around the z-axis."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"principal axes",src:o(5937).Z})),(0,a.kt)("h2",{id:"moving-our-enemy-towards-the-player"},"Moving our enemy towards the player"),(0,a.kt)("p",null,"Our enemy isn't just going to stand there! Lets make our enemy look at the player and then move towards the Player, so that the Player has to react quick or get killed. "),(0,a.kt)("h3",{id:"pointtowardsposition-block"},(0,a.kt)("inlineCode",{parentName:"h3"},"pointTowardsPosition")," block"),(0,a.kt)("p",null,"To point an object towards a position in ChromeEngine we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"GameObjects.pointTowardsPosition")," block. Here's how we can use it to point the Enemy at the player:"),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n  GameObjects.pointTowardsPosition \\( object 1 name [Enemy] Position [@player_x] [] [@player_z]\\) :: custom\n"),(0,a.kt)("p",null,"In ChromeEngine the player position is always stored in the global variables ",(0,a.kt)("inlineCode",{parentName:"p"},"@player_x"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@player_y")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@player_z"),". In edit mode the camera position is stored in these variables instead which makes it possible for us to interact with our enemy even in edit mode as if we were the player."),(0,a.kt)("h3",{id:"move-block"},(0,a.kt)("inlineCode",{parentName:"h3"},"move")," block"),(0,a.kt)("p",null,"To move an object forward by a step we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"GameObjects.move")," block. Here's how we can use it to make our Enemy move 0.1 steps in what ever direction it's facing each frame:"),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n  GameObjects.move \\( object name [Enemy] steps [0.1]\\) :: custom\n"),(0,a.kt)("h3",{id:"restricting-the-enemys-movement-and-rotation"},"Restricting the enemy's movement and rotation"),(0,a.kt)("p",null,"If we were to click play now, the enemy would point at us, move directly at us forever. However what we really want is for the Enemy to stay parallel to the ",(0,a.kt)("inlineCode",{parentName:"p"},"XZ")," plane and to stay within the bounds of it's platform."),(0,a.kt)("p",null,"We can constrain the rotation by setting the pitch rotation to 0 AFTER calling ",(0,a.kt)("inlineCode",{parentName:"p"},"pointTowardsPosition")," and we can bound the position, by only moving the Enemy when the player is within the bounds of the platform! With this our final code for the enemy Logic looks like:"),(0,a.kt)(c,{mdxType:"ScratchBlocks"},"\n    GameObjects.pointTowardsPosition \\( object 1 name [Enemy] Position [@player_x] [] [@player_z]\\) :: custom\n    GameObjects.setRotation \\( object name [Enemy] rotation \\(yaw, pitch, roll\\) [] [0] []\\) :: custom\n    if <<([abs v] of ((@player_x)-[0]))< [1.4]> and <([abs v] of ((@player_z)-[-20]))< [1.9]>>then\n    GameObjects.move \\( object name [Enemy] steps [0.1]\\) :: custom\n"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"-20")," are the x,z coordinate of the platform"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1.4")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"1.9")," are the width, height of the platform")),(0,a.kt)("h2",{id:"wrapping-up-and-additional-resources"},"Wrapping up and Additional Resources"),(0,a.kt)("p",null,"And there you have it! We've successfully set the stage for our platforms to dance and our enemies to attack. Here's what your platformer game should look like now:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Moving Objects",src:o(7760).Z})),(0,a.kt)("p",null,"For more detailed information on updating objects in ChromeEngine, you can visit ",(0,a.kt)("a",{parentName:"p",href:"/docs/user_docs/Updating%20Objects"},"Updating Objects")," in our documentation."),(0,a.kt)("p",null,"Remember, the magic of game development is all about experimentation, so don't be afraid to mix it up and make this game truly your own. Now go ahead, unleash your imagination and let your game objects bust a move!"))}u.isMDXComponent=!0},7760:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/moving-platforms-d97563a44201ad74fa9614c631df7045.png"},5937:(e,t,o)=>{o.d(t,{Z:()=>n});const n=o.p+"assets/images/yaw-pitch-roll-1077a1821410ec204ecefbb8a69bea9a.png"}}]);