"use strict";(self.webpackChunkchrome_engine_docs=self.webpackChunkchrome_engine_docs||[]).push([[345],{3905:(e,t,i)=>{i.d(t,{Zo:()=>l,kt:()=>_});var n=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function a(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var p=n.createContext({}),m=function(e){var t=n.useContext(p),i=t;return e&&(i="function"==typeof e?e(t):a(a({},t),e)),i},l=function(e){var t=m(e.components);return n.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var i=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=m(i),h=r,_=d["".concat(p,".").concat(h)]||d[h]||c[h]||o;return i?n.createElement(_,a(a({ref:t},l),{},{components:i})):n.createElement(_,a({ref:t},l))}));function _(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=i.length,a=new Array(o);a[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[d]="string"==typeof e?e:r,a[1]=s;for(var m=2;m<o;m++)a[m]=i[m];return n.createElement.apply(null,a)}return n.createElement.apply(null,i)}h.displayName="MDXCreateElement"},2364:(e,t,i)=>{i.r(t),i.d(t,{contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=i(7462),r=(i(7294),i(3905));const o={},a="_*prims",s={unversionedId:"system_docs/BSP/Prims",id:"system_docs/BSP/Prims",isDocsHomePage:!1,title:"_*prims",description:"prims is a linked list which stores pointers to the primitives. The prims linked list is manipulated during the BSP tree generation to allow the tree to point to primitives.",source:"@site/docs/system_docs/01-BSP/01-Prims.md",sourceDirName:"system_docs/01-BSP",slug:"/system_docs/BSP/Prims",permalink:"/docs/system_docs/BSP/Prims",editUrl:"https://github.com/your-github-username/your-repo-name/edit/main/docs/docs/system_docs/01-BSP/01-Prims.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"systemSidebar",previous:{title:"Intro",permalink:"/docs/system_docs/Intro"},next:{title:"Tree Generation",permalink:"/docs/system_docs/BSP/Tree Generation"}},p=[{value:"Custom Block Descriptions",id:"custom-block-descriptions",children:[{value:"<code>bsp._*prims.__init_non_dynamic__</code>",id:"bsp_prims__init_non_dynamic__",children:[]},{value:"<code>_*prim = bsp._*prims.insert_after</code>",id:"_prim--bsp_primsinsert_after",children:[]},{value:"<code>bsp._*prims.randomize_order</code>",id:"bsp_primsrandomize_order",children:[]},{value:"<code>_tmp, _tmp2 = bsp._*prims.pop</code>",id:"_tmp-_tmp2--bsp_primspop",children:[]},{value:"<code>bsp._*prims.swap</code>",id:"bsp_primsswap",children:[]},{value:"<code>bsp._*prims.sanity_check</code>",id:"bsp_primssanity_check",children:[]}]}],m=(l="ScratchBlocks",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var l;const d={toc:p},c="wrapper";function h(e){let{components:t,...i}=e;return(0,r.kt)(c,(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"_prims"},(0,r.kt)("inlineCode",{parentName:"h1"},"_*prims")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," is a linked list which stores pointers to the primitives. The ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," linked list is manipulated during the BSP tree generation to allow the tree to point to primitives."),(0,r.kt)("p",null,"The custom block definitions in the code are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bsp._*prims.__init_non_dynamic__")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_**prim = bsp._*prims.insert_after")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bsp._*prims.randomize_order")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_tmp, _tmp2 = bsp._*prims.pop")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bsp._*prims.swap")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bsp._*prims.sanity_check"))),(0,r.kt)("h2",{id:"custom-block-descriptions"},"Custom Block Descriptions"),(0,r.kt)("p",null,"Each custom block definition in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," page of the Binary Space Partitioning documentation is described in detail in this section."),(0,r.kt)("h3",{id:"bsp_prims__init_non_dynamic__"},(0,r.kt)("inlineCode",{parentName:"h3"},"bsp._*prims.__init_non_dynamic__")),(0,r.kt)(m,{mdxType:"ScratchBlocks"},"\ndefine bsp._*prims.__init_non_dynamic__\n"),(0,r.kt)("p",null,"initializes the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," linked list with non-dynamic primitives from the primitives list."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Starting from the first element in the primitives list, it iterates over the list, skipping elements belonging to dynamic GameObjects."),(0,r.kt)("li",{parentName:"ol"},"For each non-dynamic primitive, it adds an entry in the ",(0,r.kt)("inlineCode",{parentName:"li"},"_*prims"),' list containing the primitive index, two pointers to form a doubly linked list, and the side ("FRONT" or "BACK") of the primitive. ',(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},'If a primitive has a non-zero material, an entry for the "BACK" side of the primitive is also added. '))),(0,r.kt)("li",{parentName:"ol"},"The second element and the last element of the ",(0,r.kt)("inlineCode",{parentName:"li"},"_*prims"),' list are set to "null", and the tail pointer is set to the second-last element of the list.')),(0,r.kt)("h3",{id:"_prim--bsp_primsinsert_after"},(0,r.kt)("inlineCode",{parentName:"h3"},"_*prim = bsp._*prims.insert_after")),(0,r.kt)(m,{mdxType:"ScratchBlocks"},"\ndefine _**prim = bsp._*prims.insert_after \\( (*prim) (*elem) (*mem_loc) (Orientation) \\)\n"),(0,r.kt)("p",null,"Inserts a new primitive ",(0,r.kt)("inlineCode",{parentName:"p"},"*prim")," after a given element ",(0,r.kt)("inlineCode",{parentName:"p"},"*elem")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," list. optionally can specify a memory location ",(0,r.kt)("inlineCode",{parentName:"p"},"*mem_loc")," for the data to go."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"if the ",(0,r.kt)("inlineCode",{parentName:"li"},"_*prims")," list empty, appends the data at the end of the ",(0,r.kt)("inlineCode",{parentName:"li"},"_*prims")," list and returns."),(0,r.kt)("li",{parentName:"ol"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"*mem_loc")," is None:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Add the ",(0,r.kt)("inlineCode",{parentName:"li"},"_*prim")," and it's ",(0,r.kt)("inlineCode",{parentName:"li"},"Orientation")," as a new linked list node at the end of the list. "))),(0,r.kt)("li",{parentName:"ol"},"else:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"we replace the data slot at ",(0,r.kt)("inlineCode",{parentName:"li"},"*mem_loc")," with the ",(0,r.kt)("inlineCode",{parentName:"li"},"_*prim")," and it's ",(0,r.kt)("inlineCode",{parentName:"li"},"Orientation")))),(0,r.kt)("li",{parentName:"ol"},"set the correct links for the linked list such that the new node in the linked list is inserted between ",(0,r.kt)("inlineCode",{parentName:"li"},"*elem"),"  and ",(0,r.kt)("inlineCode",{parentName:"li"},"*elems")," next item.")),(0,r.kt)("h3",{id:"bsp_primsrandomize_order"},(0,r.kt)("inlineCode",{parentName:"h3"},"bsp._*prims.randomize_order")),(0,r.kt)(m,{mdxType:"ScratchBlocks"},"\ndefine bsp._*prims.randomize_order \\( (*left) (*right) \\)\n"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"bsp._*prims.randomize_order")," custom block randomizes the order of the primitives in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," list between the left and right indices. It iterates over the primitives, starting from the left index and going up to the right index, and swaps each primitive with another random primitive in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," list."),(0,r.kt)("h3",{id:"_tmp-_tmp2--bsp_primspop"},(0,r.kt)("inlineCode",{parentName:"h3"},"_tmp, _tmp2 = bsp._*prims.pop")),(0,r.kt)(m,{mdxType:"ScratchBlocks"},"\ndefine _tmp, _tmp2 = bsp._*prims.pop \\( (*elem) \\)\n"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"_tmp, _tmp2 = bsp._*prims.pop")," custom block removes a primitive from the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," list. The previous and next elements' pointers are updated to skip over the removed element. If the removed element is the last element in the list, the tail pointer is updated. The primitive and its orientation are stored, and the removed element's entries in the _*prims list are cleared."),(0,r.kt)("h3",{id:"bsp_primsswap"},(0,r.kt)("inlineCode",{parentName:"h3"},"bsp._*prims.swap")),(0,r.kt)(m,{mdxType:"ScratchBlocks"},"\ndefine bsp._*prims.swap \\( *a (*a) *b (*b) \\)\n"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"bsp._*prims.swap")," custom block swaps two primitives in the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," list. The primitives and their orientations are swapped using a temporary variable."),(0,r.kt)("h3",{id:"bsp_primssanity_check"},(0,r.kt)("inlineCode",{parentName:"h3"},"bsp._*prims.sanity_check")),(0,r.kt)(m,{mdxType:"ScratchBlocks"},"\ndefine bsp._*prims.sanity_check \\( (*left) (*right) \\)\n"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"bsp._*prims.sanity_check")," custom block checks the consistency of the ",(0,r.kt)("inlineCode",{parentName:"p"},"_*prims")," list between the left and right indices. It iterates over the primitives and checks that each primitive index is a multiple of the size of a primitive. It also checks that the previous and next element pointers for each primitive point to the correct elements. If an inconsistency is detected, a breakpoint is triggered."))}h.isMDXComponent=!0}}]);