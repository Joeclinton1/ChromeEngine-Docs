"use strict";(self.webpackChunkchrome_engine_docs=self.webpackChunkchrome_engine_docs||[]).push([[118],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=s(n),m=r,h=d["".concat(c,".").concat(m)]||d[m]||p[m]||a;return n?o.createElement(h,l(l({ref:t},u),{},{components:n})):o.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:r,l[1]=i;for(var s=2;s<a;s++)l[s]=n[s];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5136:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var o=n(7462),r=(n(7294),n(3905));const a={},l="GUI",i={unversionedId:"user_docs/GUI",id:"user_docs/GUI",isDocsHomePage:!1,title:"GUI",description:"Although Scratch already makes it easy to make a GUI, ChromeEngine provides some custom blocks to make your life even easier. These blocks go in the GUI sprite. The onTouch and onClick blocks will only apply to whatever costume is shown when the block is called. The following blocks are provided:",source:"@site/docs/user_docs/07-GUI.md",sourceDirName:"user_docs",slug:"/user_docs/GUI",permalink:"/ChromeEngine-Docs/docs/user_docs/GUI",editUrl:"https://github.com/your-github-username/your-repo-name/edit/main/docs/docs/user_docs/07-GUI.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"userSidebar",previous:{title:"Controllers",permalink:"/ChromeEngine-Docs/docs/user_docs/Controllers"},next:{title:"Settings",permalink:"/ChromeEngine-Docs/docs/user_docs/Settings"}},c=[{value:"<code>broadcastOnClick</code>",id:"broadcastonclick",children:[]},{value:"<code>playSoundOnClick</code>",id:"playsoundonclick",children:[]},{value:"<code>set/toggleStateOnClick</code>",id:"settogglestateonclick",children:[]},{value:"<code>scaleOnTouch</code>",id:"scaleontouch",children:[]}],s=(u="ScratchBlocks",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var u;const d={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gui"},"GUI"),(0,r.kt)("p",null,"Although Scratch already makes it easy to make a GUI, ChromeEngine provides some custom blocks to make your life even easier. These blocks go in the ",(0,r.kt)("inlineCode",{parentName:"p"},"GUI")," sprite. The onTouch and onClick blocks will only apply to whatever costume is shown when the block is called. The following blocks are provided:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"broadcastOnClick")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"playSoundOnClick")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"set/toggleStateOnClick")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"scaleOnTouch"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"FAQ: what is ",(0,r.kt)("inlineCode",{parentName:"strong"},"GameState?")),"\nIn Scratch there is no way for you to provide a name of a variable and update it through a custom block, however as a workaround we provide a list called ",(0,r.kt)("inlineCode",{parentName:"p"},"GameState"),' which can be used to store labelled data. This means we can update "variables" through GUI custom blocks which is very useful.'),(0,r.kt)("h3",{id:"broadcastonclick"},(0,r.kt)("inlineCode",{parentName:"h3"},"broadcastOnClick")),(0,r.kt)(s,{mdxType:"ScratchBlocks"},"\nGUI.broadcastOnClick \\( message label [] \\) :: custom\n"),(0,r.kt)("p",null,"If the current GUI element is clicked, it broadcasts the message with label ",(0,r.kt)("inlineCode",{parentName:"p"},"message label")),(0,r.kt)("h3",{id:"playsoundonclick"},(0,r.kt)("inlineCode",{parentName:"h3"},"playSoundOnClick")),(0,r.kt)(s,{mdxType:"ScratchBlocks"},"\nGUI.playSoundOnClick \\( sound label [] \\) :: custom\n"),(0,r.kt)("p",null,"If the current GUI element is clicked, it plays the sound specified by sound label."),(0,r.kt)("h3",{id:"settogglestateonclick"},(0,r.kt)("inlineCode",{parentName:"h3"},"set/toggleStateOnClick")),(0,r.kt)(s,{mdxType:"ScratchBlocks"},"\nGUI.set/toggleStateOnClick \\( state label  [] state value [] toggle? <> \\) :: custom\n"),(0,r.kt)("p",null,"If the current GUI element is clicked it sets the ",(0,r.kt)("inlineCode",{parentName:"p"},"GameState")," variable with label specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"state label")," to the value given by ",(0,r.kt)("inlineCode",{parentName:"p"},"state value"),". If ",(0,r.kt)("inlineCode",{parentName:"p"},"toggle?")," is set to True then it will flip a boolean GameState value, which is useful for toggling things in game."),(0,r.kt)("h3",{id:"scaleontouch"},(0,r.kt)("inlineCode",{parentName:"h3"},"scaleOnTouch")),(0,r.kt)(s,{mdxType:"ScratchBlocks"},"\nGUI.scaleOnTouch \\( scale factor [] \\) :: custom\n"),(0,r.kt)("p",null,"If the current GUI element is touched by the mouse pointer it scales that element by ",(0,r.kt)("inlineCode",{parentName:"p"},"scale factor"),"."))}m.isMDXComponent=!0}}]);